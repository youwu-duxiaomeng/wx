#### debug

由于仅比对执行路径，并不一定能直接找到bug，就像发现跳转不一样，但是发现该基本快寄存器本就不一样，然后跳转也因此不一样，所以此种情况下需要比对寄存器的值（进一步是比较内存）

现在脚本在vpr那个测试样例上可以做到比对大约五万个基本块寄存器内容完全一致（除eflags）

也找到了第一个bug

工具大致思路：利用qemu -d cpu,fpu可以dump出每个基本块执行前的寄存器信息。然后进行比对



#### 难点及解决方案

- qemu基本块划分与qemu-i386不同-->找出不同：带有rep / repne 前缀的指令也会被当做基本快的结尾，故先用正确的qemu-i386 加上选项 -d in_asm 获得每个基本快的信息，用脚本整理成知道pc即可获得该pc是否以带有rep的指令，然后处理一遍qemu的输出即可获得基本快相同的结果（需要加上 nochain）
- 由于环境变量不一致，要在相同机器，的相同目录下运行程序，要保证环境变量完全一致，一个字节都不能差。
- aux vector 里会放一些随机数，程序会读取，通过修改qemu源码，全放0，应该对程序无影响
- 程序会通过rdtsc指令读取时间，由于我们没有处理，所以直接将qemu的helper函数改成什么都不干
- mov指令目标是段寄存器的时候，段寄存器更新不正确（一般不影响程序结果），通过修改我们的翻译函数使之和qemu达到中相同的效果。



#### 后续

由于程序输出过于长（完全输出要几十G），程序运行时间也长，可以通过区间打印，间隔打印，或者进行二分查找逐渐找到bug的发生地。还有控制当pc为什么时/执行了多少时打印。

